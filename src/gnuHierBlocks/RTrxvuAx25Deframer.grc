options:
  parameters:
    author: Austin
    catch_exceptions: 'True'
    category: '[RADSAT-SK]'
    cmake_opt: ''
    comment: ''
    copyright: ''
    description: ''
    gen_cmake: 'On'
    gen_linking: dynamic
    generate_options: hb
    hier_block_src_path: '.:'
    id: trxvuAx25Deframer
    max_nouts: '0'
    output_language: python
    placement: (0,0)
    qt_qss_theme: ''
    realtime_scheduling: ''
    run: 'True'
    run_command: '{python} -u {filename}'
    run_options: prompt
    sizing_mode: fixed
    thread_safe_setters: ''
    title: TRXVU AX.25 Deframer
    window_size: (1000,1000)
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [8, 8]
    rotation: 0
    state: enabled

blocks:
- name: digital_descrambler_bb_0
  id: digital_descrambler_bb
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    len: '16'
    mask: '0x21'
    maxoutbuf: '0'
    minoutbuf: '0'
    seed: '0x00'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [576, 244.0]
    rotation: 0
    state: enabled
- name: digital_diff_decoder_bb_0
  id: digital_diff_decoder_bb
  parameters:
    affinity: ''
    alias: ''
    coding: digital.DIFF_NRZI
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    modulus: '2'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [384, 260.0]
    rotation: 0
    state: enabled
- name: epy_block_1_0
  id: epy_block
  parameters:
    _source_code: "import numpy as np\nfrom gnuradio import gr\nfrom time import sleep\n\
      import pmt\n\nimport crc\n\ndef crcAugCcitt():\n    width = 16\n    poly=0x1021\n\
      \    init_value=0xFFFF\n    final_xor_value=0xFFFF\n    reverse_input=True\n\
      \    reverse_output=True\n    configuration = crc.Configuration(width, poly,\
      \ init_value, final_xor_value, reverse_input, reverse_output)\n    return crc.CrcCalculator(configuration,\
      \ True)\n\n\ndef limitChr(chars, returnIllegalChars=True):\n    \"\"\"\n   \
      \ Routine to convert a intiger to a ASCII character but exclude non-visual ASCII\
      \ codes.\n\n        chars: a integer or a list of integers representing a ASCII\
      \ code.\n\n       return: a string of converted ASCII characters.\n    \"\"\"\
      \n    if not isinstance(chars, (list, np.ndarray)):\n        chars = [chars]\n\
      \    output = \"\"\n    for i in chars:\n        if ((0x1F < i < 0x7F) and i\
      \ != 0x8D) or i == 10 or (0xA0 < i <= 0xFF):\n            output += chr(i)\n\
      \        elif returnIllegalChars:\n            output += f\"\\\\x{i:02x}\"\n\
      \    return output\n\n\n\ndef insertBit(val, boolVal):\n    #return (val <<\
      \ type(val)(1)) + boolVal\n    return (val >> type(val)(1)) + (boolVal << type(val)(7))\n\
      \    \ndef decodeCallsign(chars):\n    return bytes([i >> 1 for i in chars]).decode('ascii',\
      \ errors='backslashreplace')\n\n\nclass deframer:\n    def __init__(self, flag=0x7e,\
      \ maxLen=255, minLen=0, enableCrc=True):\n        self._flag = flag\n      \
      \  self._max = maxLen*8  # subtract flag lengths\n        self._min = minLen*8\n\
      \        self.__startFlag = np.uint8(0)\n        self.__endFlag = np.uint8(0)\n\
      \        self.__body = [i for i in range(maxLen)] # np.zeros((maxLen,), dtype=np.uint8)\n\
      \        self.__bodyLen = -7\n        self.__stuffingCounter = 0\n        self.crc_calculator\
      \ = crcAugCcitt()\n        self.enableCrc = enableCrc\n\n\n    def work(self,\
      \ input_items):\n        \"\"\"\n        This is where the work is done in the\
      \ GNURadio block.\n\n        algorith: double slidding window searching for\
      \ start/end flag with both windows\n        encapsulating the message body implemented\
      \ as state mechine.\n        \"\"\"\n        inputLength = len(input_items)\n\
      \        \n        output = []\n        pos = 0\n        while pos < inputLength:\
      \  # Recursive like algorithm.\n            if self.__bodyLen >= self._max:\
      \                                             # Reset window message body to\
      \ bigger them max.\n                self.__startFlag = np.uint8(0)\n       \
      \         self.__endFlag = np.uint8(0)\n                self.__bodyLen = -7\n\
      \                \n            if self.__startFlag != self._flag:          \
      \                                # Case: first flag search.\n              \
      \  self.__startFlag = insertBit(self.__startFlag, input_items[pos])\n      \
      \          \n            elif self.__endFlag != self._flag:                \
      \                          # Case: last flag search.\n                if self.__bodyLen\
      \ >= 0:\n                    nextBit = self.__endFlag & np.uint8(1)\n      \
      \              if nextBit == 0 and self.__stuffingCounter == 5:\n          \
      \              self.__stuffingCounter = 0\n                        self.__bodyLen\
      \ -= 1\n                    else:\n                        self.__body[self.__bodyLen\
      \ // 8] = insertBit(self.__body[self.__bodyLen // 8], nextBit)\n           \
      \         self.__stuffingCounter = self.__stuffingCounter * nextBit + nextBit\n\
      \                self.__endFlag = insertBit(self.__endFlag, input_items[pos])\n\
      \                self.__bodyLen += 1\n                \n            elif (self.__startFlag\
      \ == self._flag and self.__endFlag == self._flag):     # Case: message found\
      \ and validation.\n                crcCalc = self.crc_calculator.calculate_checksum(bytes(self.__body[0:(self.__bodyLen//8)-2]))\n\
      \                crcRx = (self.__body[self.__bodyLen//8-1] << 8) + self.__body[self.__bodyLen//8-2]\n\
      \                crcRes = crcCalc == crcRx\n                if not self.enableCrc:\n\
      \                \tcrcRes = True\n                if not self.__bodyLen % 8\
      \ and self.__bodyLen >= self._min and crcRes:\n                    output.append(self.__body[0:self.__bodyLen//8])\n\
      \                    self.__startFlag = np.uint8(0)\n                self.__endFlag\
      \ = np.uint8(0)\n                self.__bodyLen = -7\n            pos += 1\n\
      \        return output\n        \n        \nclass blk(gr.sync_block):\n    def\
      \ __init__(self, flag=0b01111110, maxLen=255, minLen=0, output_Type=0, enableCrc=True):\n\
      \        gr.sync_block.__init__(\n            self,\n            name=\"CLI\
      \ Print Sink\",\n            in_sig=[np.uint8],\n            out_sig=None,\n\
      \        )\n        self.message_port_register_out(pmt.intern('msg_out'))\n\
      \        self.removeAx25 = True\n        \n        self.output_type = output_Type\n\
      \        self.deframerObj = deframer(flag, maxLen, minLen, enableCrc)\n    \
      \    \n    def work(self, input_items, output_items):\n        for i in self.deframerObj.work(input_items[0]):\n\
      \            sendData = i[16:-2] if self.removeAx25 else i\n            self.message_port_pub(pmt.intern('msg_out'),\
      \ pmt.to_pmt(np.array(bytearray(sendData), dtype=np.uint8)))\n            if\
      \ self.output_type == 0:\n                pass\n            elif self.output_type\
      \ == 1:\n                print(\n                f\"\\n\\\nFrom: {decodeCallsign(i[7:13])}\
      \ #{i[13] >> 1 & 0xf} --- {bin(i[13])}\\n\\\n To : {decodeCallsign(i[0:6]) }\
      \ #{i[6] >> 1 & 0xf} --- {bin(i[6])}\\n\\\nCRC : 0x{(i[-1] << 8) + i[-2]:04X}\\\
      n\\\n----------------------------------\\n\\\n{bytes(i[16:-2]).decode('ascii',\
      \ errors='backslashreplace')}\")\n            elif self.output_type == 2:\n\
      \                print(('\\n' + ' 0x{:02X}'*len(i)).format(*i))\n          \
      \  elif self.output_type == 3:\n                print(\"\\n\", limitChr(i))\n\
      \            elif self.output_type == 4:\n                print('\\n{:<.60s}'.format(''.join([f\"\
      {J:02X}\" for J in i])))\n            elif self.output_type == 5:\n        \
      \        print(\"\\n\" + bytes(i).decode('ascii', errors='backslashreplace'))\n\
      \            elif self.output_type == 6:\n                print(\"\\n\", i)\n\
      \            elif self.output_type == 7:\n                print(('\\n'+'{:02X}'*len(i)).format(*i))\n\
      \            \t\n        self.consume(0, len(input_items[0]))  # empty input.\
      \ fixes overflow\n        return 0\n\nif __name__ == \"__main__\":\n    testobj\
      \ = deframer() \n    \n    flag = f'{0x7e:08b}'\n    body = \"000000000000000\"\
      +flag\n    bodyText = [0x86, 0xA2, 0x40, 0x40, 0x40, 0x40, 0x60, 0xAE, 0x64,\
      \ 0x8C, 0xA6,\n0x40, 0x40, 0x68, 0xA4,0x8A, 0x98, 0x82, 0xB2, 0x40, 0x61, 0x3F,\n\
      0xF0, 0x54, 0x65, 0x73,0x74]\n    bodyText2 = [\n    0xa4, 0x82, 0x88, \n  \
      \  0xa6, 0x82, 0xa8, 0xf4, \n    \n    0xa4, 0x82, 0x88, \n    0xa6, 0x82, 0xa8,\
      \ 0x63, \n    0x03, 0xf0, \n    0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2d, 0x53,\
      \ 0x4b, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2d, 0x53, 0x4b, 0x20, 0x52,\
      \ 0x41, 0x44, 0x53, 0x41, 0x54, 0x2d, 0x53, 0x4b, 0x20, 0x52, 0x41, 0x44, 0x53,\
      \ 0x41, 0x54, 0x2d, 0x53, 0x4b, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2d,\
      \ 0x53, 0x4b, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2d, 0x53, 0x4b, 0x20,\
      \ 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2d, 0x53, 0x4b, 0x20, 0x52, 0x41, 0x44,\
      \ 0x53, 0x41, 0x54, 0x2d, 0x53, 0x4b, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54,\
      \ 0x2d, 0x53, 0x4b, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2d, 0x53, 0x4b,\
      \ 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2d, 0x53, 0x4b, 0x20, 0x52, 0x41,\
      \ 0x44, 0x53, 0x41, 0x54, 0x2d, 0x53, 0x4b, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41,\
      \ 0x54, 0x2d, 0x53, 0x4b, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2d, 0x53,\
      \ 0x4b, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2d, 0x53, 0x4b, 0x20, 0x52,\
      \ 0x41, 0x44, 0x53, 0x41, 0x54, 0x2d, 0x53, 0x4b, 0x20, 0x52, 0x41, 0x44, 0x53,\
      \ 0x41, 0x54, 0x2d, 0x53, 0x4b, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2d,\
      \ 0x53, 0x4b, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2d, 0x53, 0x4b, 0x20,\
      \ 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2d, 0x53, 0x4b, 0x20]\n    #bodyText\
      \ = \"test text 1234\"\n    hexBody =  ''\n    for i in bodyText:\n        hexBody\
      \ += f'{i:02X}'\n        body += f'{i:08b}'\n    body += flag+\"00000000000000000\"\
      \n    data = []\n    for i in body:\n        data.append(np.uint8(int(i)))\n\
      \    #print(bodyText)\n    #print(hexBody)\n    #print(f\"\\n{bytes(testobj.work(data)[0]).decode('ascii',\
      \ errors='backslashreplace')}\")\n    #print()\n    \n    \n"
    affinity: ''
    alias: ''
    comment: ''
    enableCrc: 'True'
    flag: '0x7e'
    maxLen: '255'
    maxoutbuf: '0'
    minLen: '5'
    minoutbuf: '0'
    output_Type: '1'
  states:
    _io_cache: ('CLI Print Sink', 'blk', [('flag', '126'), ('maxLen', '255'), ('minLen',
      '0'), ('output_Type', '0'), ('enableCrc', 'True')], [('0', 'byte', 1)], [('msg_out',
      'message', 1)], '', [])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [720, 228.0]
    rotation: 0
    state: enabled
- name: pad_sink_0
  id: pad_sink
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    label: msg_out
    num_streams: '1'
    optional: 'True'
    type: message
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [904, 260.0]
    rotation: 0
    state: true
- name: pad_source_0
  id: pad_source
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    label: in
    maxoutbuf: '0'
    minoutbuf: '0'
    num_streams: '1'
    optional: 'False'
    type: byte
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [248, 260.0]
    rotation: 0
    state: true

connections:
- [digital_descrambler_bb_0, '0', epy_block_1_0, '0']
- [digital_diff_decoder_bb_0, '0', digital_descrambler_bb_0, '0']
- [epy_block_1_0, msg_out, pad_sink_0, in]
- [pad_source_0, '0', digital_diff_decoder_bb_0, '0']

metadata:
  file_format: 1
