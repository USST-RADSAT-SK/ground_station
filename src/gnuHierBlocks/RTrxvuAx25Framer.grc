options:
  parameters:
    author: Austin
    catch_exceptions: 'True'
    category: '[RADSAT-SK]'
    cmake_opt: ''
    comment: ''
    copyright: ''
    description: ''
    gen_cmake: 'On'
    gen_linking: dynamic
    generate_options: hb
    hier_block_src_path: '.:'
    id: trxvuAx25Framer
    max_nouts: '0'
    output_language: python
    placement: (0,0)
    qt_qss_theme: ''
    realtime_scheduling: ''
    run: 'True'
    run_command: '{python} -u {filename}'
    run_options: prompt
    sizing_mode: fixed
    thread_safe_setters: ''
    title: TRXVU AX.25 Framer
    window_size: (1000,1000)
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [8, 12.0]
    rotation: 0
    state: enabled

blocks:
- name: SamplesPerSymbol
  id: parameter
  parameters:
    alias: ''
    comment: ''
    hide: none
    label: Samples Per Symbol
    short_id: ''
    type: intx
    value: '0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [528, 12.0]
    rotation: 0
    state: true
- name: ax25_framer
  id: epy_block
  parameters:
    _source_code: "import numpy as np\nimport crc\nimport os\nimport sys\nimport pmt\n\
      from time import time\nfrom gnuradio import gr\n\ndef crcAugCcitt():\n    width\
      \ = 16\n    poly=0x1021\n    init_value=0xFFFF\n    final_xor_value=0xFFFF\n\
      \    reverse_input=True\n    reverse_output=True\n    configuration = crc.Configuration(width,\
      \ poly, init_value, final_xor_value, reverse_input, reverse_output)\n    return\
      \ crc.CrcCalculator(configuration, True)\n\n\nprintFunc = print\n\ndef p(*args,\
      \ **kwargs):\n    global pcnt\n    printFunc(f'Loc {pcnt}: ', *args, **kwargs)\n\
      \    pcnt += 1\n    \ndef end():\n    global pcnt\n    pcnt = 0\n\n\nclass blk(gr.sync_block):\
      \  # other base classes are basic_block, decim_block, interp_block\n    \"\"\
      \"Embedded Python Block example - a simple multiply const\"\"\"\n    crc_calculator\
      \ = crcAugCcitt()\n    def __init__(self, destinationAddress=\"RADSAT\", destinationIndex=1,\
      \ sourceAddress=\"RADSAT\", sourceIndex=10, ctl=0xF0, pid=0x03, samplesPerSymbol=None):\
      \ # UI frame could be 0xf or 0x10\n        gr.sync_block.__init__(\n       \
      \     self,\n            name='Embedded Python Block',   # will show up in GRC\n\
      \            in_sig=None,\n            out_sig=[np.byte]\n        )\n      \
      \  self.message_port_register_in(pmt.intern('msg_in'))\n        self.set_msg_handler(pmt.intern('msg_in'),\
      \ self.handle_msg)\n        self.xmitBuffer = []\n        self.flagBuffer =\
      \ []\n        self.flagBufferUnderFlow = 0\n        self.samplesPerSymbol =\
      \ 0 if not samplesPerSymbol else samplesPerSymbol\n        self.timer = time()\n\
      \        self.waiting = 1\n\n        self.flag = [(0x7e >> i) & 1 for i in range(8)]\n\
      \        self.sendFlag = True\n        \n        self.head = \\\n        [ord(i)<<1\
      \ for i in destinationAddress] + [0b01100000 + ((destinationIndex&0xf)<<1) +\
      \ 0] + \\\n        [ord(i)<<1 for i in sourceAddress] + [0b01100000 + ((sourceIndex&0xf)<<1)\
      \ + 1] + \\\n        [ctl, pid]\n        \n        \n    def handle_msg(self,\
      \ msg):\n        try:\n            msgstr = []\n            if pmt.is_u8vector(msg):\n\
      \                msgstr = list(pmt.to_python(msg))\n            elif pmt.is_string(msg):\n\
      \                msgstr = list(pmt.serialize_str(msg)[3:])\n            print(\"\
      Adding message to xmitBuffer: b'\" +\"\".join([f\"\\\\x{i:02x}\" for i in bytes(msgstr)])\
      \ + \"'\")\n            if len(msgstr):\n                frame = self.head +\
      \ msgstr\n                checksum = self.crc_calculator.calculate_checksum(bytes(frame))\n\
      \                frame += [checksum & 0xff, (checksum >> 8) & 0xff]\n      \
      \          buff = self.flag[:]\n                ones = 0  # number of consecutive\
      \ ones\n                for byte in frame:\n                    for _ in range(8):\n\
      \                        # Transmit byte LSB first\n                       \
      \ x = byte & np.byte(1)\n                        buff.append(x)\n          \
      \              ones = ones * x + x\n                        if ones == 5:\n\
      \                            # Bit-stuff\n                            buff.append(0)\n\
      \                            ones = 0\n                        byte >>= 1\n\
      \                        \n                frame = buff + self.flag\n      \
      \          self.xmitBuffer.append(frame);\n                #print(len(self.xmitBuffer),\
      \ self.xmitBuffer[-1])\n        except Exception as e:\n            exc_type,\
      \ exc_obj, exc_tb = sys.exc_info()\n            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]\n\
      \            printFunc(f\"Exception {exc_type} on Line {exc_tb.tb_lineno} in\
      \ {fname}:\")\n            printFunc(e)\n        \n        \n    def work(self,\
      \ input_items, output_items):\n        try:\n            if len(self.xmitBuffer):\n\
      \                buflen = len(output_items[0])\n                _len = len(self.xmitBuffer[0])\n\
      \                if self.waiting:\n                    self.add_item_tag(0,\n\
      \                            self.nitems_written(0),\n                     \
      \       pmt.intern(\"tx_pkt_len\"),\n                            pmt.to_pmt(_len*self.samplesPerSymbol)\n\
      \                    )\n                self.waiting = 0\n                for\
      \ i in range(min(buflen, _len)):\n                    output_items[0][i] = self.xmitBuffer[0].pop(0)\n\
      \                if buflen >= _len:\n                    self.timer += _len\
      \ * 1/9600\n                    self.waiting = 1\n                    self.xmitBuffer.pop(0)\n\
      \                return _len\n            else:\n                timer = time()\
      \ - self.timer\n                sendNumber = min(len(output_items[0])//8, int(timer//(8/9600)))\n\
      \                if sendNumber > 0: \n                    self.timer = time()\n\
      \                else:\n                    return 0\n                self.add_item_tag(0,\n\
      \                            self.nitems_written(0),\n                     \
      \       pmt.intern(\"tx_pkt_len\"),\n                            pmt.to_pmt(8*self.samplesPerSymbol*sendNumber)\n\
      \                    )\n                output_items[0][:len(self.flag) * sendNumber]\
      \ = self.flag * sendNumber\n                return len(self.flag) * sendNumber\n\
      \        except Exception as e:\n            print(f\"\"\"Error here\n     \
      \       flag = {self.flag}\n            int(timer//(8/9600)) = {int(timer//(8/9600))}\n\
      \            timer = {timer}\n            sendNumber = {sendNumber}\n      \
      \      len(output_items[0]) = {len(output_items[0])}\nDone\"\"\")\n        \
      \    exc_type, exc_obj, exc_tb = sys.exc_info()\n            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]\n\
      \            printFunc(f\"Exception {exc_type} on Line {exc_tb.tb_lineno} in\
      \ {fname}:\")\n            printFunc(e)\n        \nif __name__ == \"__main__\"\
      :\n    \n\n    data = bytes((0x52, 0x82, 0x88, 0xA6, 0x82, 0xA8, 0xF4, 0xA4,\
      \ 0x82, 0x88, 0xA6, 0x82, 0xA8, 0x63, 0x03, 0xF0, 0x52, 0x41, 0x44, 0x53, 0x41,\
      \ 0x54, 0x2D, 0x53, 0x4B, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2D, 0x53,\
      \ 0x4B, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2D, 0x53, 0x4B, 0x20, 0x52,\
      \ 0x41, 0x44, 0x53, 0x41, 0x54, 0x2D, 0x53, 0x4B, 0x20, 0x52, 0x41, 0x44, 0x53,\
      \ 0x41, 0x54, 0x2D, 0x53, 0x4B, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2D,\
      \ 0x53, 0x4B, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2D, 0x53, 0x4B, 0x20,\
      \ 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2D, 0x53, 0x4B, 0x20, 0x52, 0x41, 0x44,\
      \ 0x53, 0x41, 0x54, 0x2D, 0x53, 0x4B, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54,\
      \ 0x2D, 0x53, 0x4B, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2D, 0x53, 0x4B,\
      \ 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2D, 0x53, 0x4B, 0x20, 0x52, 0x41,\
      \ 0x44, 0x53, 0x41, 0x54, 0x2D, 0x53, 0x4B, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41,\
      \ 0x54, 0x2D, 0x53, 0x4B, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2D, 0x53,\
      \ 0x4B, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2D, 0x53, 0x4B, 0x20, 0x52,\
      \ 0x41, 0x44, 0x53, 0x41, 0x54, 0x2D, 0x53, 0x4B, 0x20, 0x52, 0x41, 0x44, 0x53,\
      \ 0x41, 0x54, 0x2D, 0x53, 0x4B, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2D,\
      \ 0x53, 0x4B, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2D, 0x53, 0x4B, 0x20))\n\
      \t\n    data2 = bytes((0xA4, 0x82, 0x88, 0xA6, 0x82, 0xA8, 0xF4, 0xA4, 0x82,\
      \ 0x88, 0xA6, 0x82, 0xA8, 0x63, 0x03, 0xF0, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54,\
      \ 0x2D, 0x53, 0x4B, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2D, 0x53, 0x4B,\
      \ 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2D, 0x53, 0x4B, 0x20, 0x52, 0x41,\
      \ 0x44, 0x53, 0x41, 0x54, 0x2D, 0x53, 0x4B, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41,\
      \ 0x54, 0x2D, 0x53, 0x4B, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2D, 0x53,\
      \ 0x4B, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2D, 0x53, 0x4B, 0x20, 0x52,\
      \ 0x41, 0x44, 0x53, 0x41, 0x54, 0x2D, 0x53, 0x4B, 0x20, 0x52, 0x41, 0x44, 0x53,\
      \ 0x41, 0x54, 0x2D, 0x53, 0x4B, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2D,\
      \ 0x53, 0x4B, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2D, 0x53, 0x4B, 0x20,\
      \ 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2D, 0x53, 0x4B, 0x20, 0x52, 0x41, 0x44,\
      \ 0x53, 0x41, 0x54, 0x2D, 0x53, 0x4B, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54,\
      \ 0x2D, 0x53, 0x4B, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2D, 0x53, 0x4B,\
      \ 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2D, 0x53, 0x4B, 0x20, 0x52, 0x41,\
      \ 0x44, 0x53, 0x41, 0x54, 0x2D, 0x53, 0x4B, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41,\
      \ 0x54, 0x2D, 0x53, 0x4B, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2D, 0x53,\
      \ 0x4B, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2D, 0x53, 0x4B, 0x20))\n\
      \t\n    crc_calculator = crcAugCcitt()\n    print(\"False\", hex(crc_calculator.calculate_checksum(data)))\n\
      \    print(\"True \", hex(crc_calculator.calculate_checksum(data2)))\n\t\n\t\
      \n\t\n\t\n\t\n\t\n\t\n\t\n\t\n           \n"
    affinity: ''
    alias: ''
    comment: ''
    ctl: '0x03'
    destinationAddress: destinationCallsign
    destinationIndex: destinationSsid
    maxoutbuf: '0'
    minoutbuf: '0'
    pid: '0xf0'
    samplesPerSymbol: SamplesPerSymbol
    sourceAddress: sourceCallsign
    sourceIndex: sourceSsid
  states:
    _io_cache: ('Embedded Python Block', 'blk', [('destinationAddress', "'RADSAT'"),
      ('destinationIndex', '1'), ('sourceAddress', "'RADSAT'"), ('sourceIndex', '10'),
      ('ctl', '240'), ('pid', '3'), ('samplesPerSymbol', 'None')], [('msg_in', 'message',
      1)], [('0', 'byte', 1)], 'Embedded Python Block example - a simple multiply
      const', ['samplesPerSymbol'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [368, 260.0]
    rotation: 0
    state: enabled
- name: destinationCallsign
  id: parameter
  parameters:
    alias: ''
    comment: ''
    hide: none
    label: Destination Callsign
    short_id: ''
    type: str
    value: NOCALL
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [232, 12.0]
    rotation: 0
    state: true
- name: destinationSsid
  id: parameter
  parameters:
    alias: ''
    comment: ''
    hide: none
    label: Destination SSID
    short_id: ''
    type: intx
    value: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [232, 108.0]
    rotation: 0
    state: true
- name: digital_diff_encoder_bb_0
  id: digital_diff_encoder_bb
  parameters:
    affinity: ''
    alias: ''
    coding: digital.DIFF_NRZI
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    modulus: '2'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [728, 308.0]
    rotation: 0
    state: true
- name: digital_scrambler_bb_0
  id: digital_scrambler_bb
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    len: '16'
    mask: '0x21'
    maxoutbuf: '0'
    minoutbuf: '0'
    seed: '0x00'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [600, 292.0]
    rotation: 0
    state: enabled
- name: pad_sink_0
  id: pad_sink
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    label: out
    num_streams: '1'
    optional: 'False'
    type: byte
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [920, 308.0]
    rotation: 0
    state: true
- name: pad_source_0
  id: pad_source
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    label: Info in
    maxoutbuf: '0'
    minoutbuf: '0'
    num_streams: '1'
    optional: 'True'
    type: message
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [160, 308.0]
    rotation: 0
    state: true
- name: pad_source_0_0
  id: pad_source
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    label: Ctrl in
    maxoutbuf: '0'
    minoutbuf: '0'
    num_streams: '1'
    optional: 'True'
    type: message
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [160, 356.0]
    rotation: 0
    state: disabled
- name: sourceCallsign
  id: parameter
  parameters:
    alias: ''
    comment: ''
    hide: none
    label: Source Callsign
    short_id: ''
    type: str
    value: NOCALL
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [392, 12.0]
    rotation: 0
    state: true
- name: sourceSsid
  id: parameter
  parameters:
    alias: ''
    comment: ''
    hide: none
    label: Source SSID
    short_id: ''
    type: intx
    value: '2'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [392, 108.0]
    rotation: 0
    state: true

connections:
- [ax25_framer, '0', digital_scrambler_bb_0, '0']
- [digital_diff_encoder_bb_0, '0', pad_sink_0, '0']
- [digital_scrambler_bb_0, '0', digital_diff_encoder_bb_0, '0']
- [pad_source_0, out, ax25_framer, msg_in]
- [pad_source_0_0, out, ax25_framer, msg_in]

metadata:
  file_format: 1
