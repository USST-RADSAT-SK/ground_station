options:
  parameters:
    author: Austin
    catch_exceptions: 'True'
    category: '[RADSAT-SK]'
    cmake_opt: ''
    comment: ''
    copyright: ''
    description: ''
    gen_cmake: 'On'
    gen_linking: dynamic
    generate_options: hb
    hier_block_src_path: '.:'
    id: trxvuAx25Framer
    max_nouts: '0'
    output_language: python
    placement: (0,0)
    qt_qss_theme: ''
    realtime_scheduling: ''
    run: 'True'
    run_command: '{python} -u {filename}'
    run_options: prompt
    sizing_mode: fixed
    thread_safe_setters: ''
    title: TRXVU AX.25 Framer
    window_size: (1000,1000)
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [8, 12.0]
    rotation: 0
    state: enabled

blocks:
- name: ax25_framer
  id: epy_block
  parameters:
    _source_code: "import numpy as np\nimport crc\nimport os\nimport sys\nimport pmt\n\
      from time import time\nfrom gnuradio import gr\n\ndef crcAugCcitt():\n    width\
      \ = 16\n    poly=0x1021\n    init_value=0xFFFF\n    final_xor_value=0xFFFF\n\
      \    reverse_input=True\n    reverse_output=True\n    configuration = crc.Configuration(width,\
      \ poly, init_value, final_xor_value, reverse_input, reverse_output)\n    return\
      \ crc.CrcCalculator(configuration, True)\n\n\nprintFunc = print\n\ndef p(*args,\
      \ **kwargs):\n    global pcnt\n    printFunc(f'Loc {pcnt}: ', *args, **kwargs)\n\
      \    pcnt += 1\n    \ndef end():\n    global pcnt\n    pcnt = 0\n\n\nclass blk(gr.sync_block):\
      \  # other base classes are basic_block, decim_block, interp_block\n    \"\"\
      \"Embedded Python Block example - a simple multiply const\"\"\"\n    crc_calculator\
      \ = crcAugCcitt()\n    def __init__(self, destinationAddress=\"RADSAT\", destinationIndex=1,\
      \ sourceAddress=\"RADSAT\", sourceIndex=10, ctl=0xF0, pid=0x03): # UI frame\
      \ could be 0xf or 0x10\n        gr.sync_block.__init__(\n            self,\n\
      \            name='Embedded Python Block',   # will show up in GRC\n       \
      \     in_sig=None,\n            out_sig=[np.byte]\n        )\n        self.message_port_register_in(pmt.intern('msg_in'))\n\
      \        self.set_msg_handler(pmt.intern('msg_in'), self.handle_msg)\n     \
      \   self.xmitBuffer = []\n        \n        self.timer = time()\n        self.waiting\
      \ = 1\n\n        self.flag = [(0x7e >> i) & 1 for i in range(8)]\n        self.sendFlag\
      \ = True\n        \n        self.head = \\\n        [ord(i)<<1 for i in destinationAddress]\
      \ + [0b01100000 + ((destinationIndex&0xf)<<1) + 0] + \\\n        [ord(i)<<1\
      \ for i in sourceAddress] + [0b01100000 + ((sourceIndex&0xf)<<1) + 1] + \\\n\
      \        [ctl, pid]\n        \n        \n    def handle_msg(self, msg):\n  \
      \      try:\n            if pmt.is_u8vector(msg):\n                msgstr =\
      \ list(pmt.to_python(msg))\n            elif pmt.is_string(msg):\n         \
      \       msgstr = list(pmt.serialize_str(msg)[3:])\n            if len(msgstr):\n\
      \                frame = self.head + msgstr\n                checksum = self.crc_calculator.calculate_checksum(bytes(frame))\n\
      \                frame += [checksum & 0xff, (checksum >> 8) & 0xff]\n      \
      \          buff = self.flag[:]\n                ones = 0  # number of consecutive\
      \ ones\n                for byte in frame:\n                    for _ in range(8):\n\
      \                        # Transmit byte LSB first\n                       \
      \ x = byte & np.byte(1)\n                        buff.append(x)\n          \
      \              ones = ones * x + x\n                        if ones == 5:\n\
      \                            # Bit-stuff\n                            buff.append(0)\n\
      \                            ones = 0\n                        byte >>= 1\n\
      \                        \n                frame = buff + self.flag\n      \
      \          self.xmitBuffer.append(frame);\n                #print(len(self.xmitBuffer),\
      \ self.xmitBuffer[-1])\n        except Exception as e:\n            exc_type,\
      \ exc_obj, exc_tb = sys.exc_info()\n            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]\n\
      \            printFunc(f\"Exception {exc_type} on Line {exc_tb.tb_lineno} in\
      \ {fname}:\")\n            printFunc(e)\n        end()\n        \n        \n\
      \    def work(self, input_items, output_items):\n        if len(self.xmitBuffer):\n\
      \            buflen = len(output_items[0])\n            _len = len(self.xmitBuffer[0])\n\
      \            if self.waiting:\n                self.add_item_tag(0,\n      \
      \                    self.nitems_written(0),\n                          pmt.intern(\"\
      tx_pkt_len\"),\n                          pmt.to_pmt(_len*60)\n            \
      \    )\n                timestamp = time()\n            self.waiting = 0\n \
      \           print(f\"_len = {_len}\")\n            print(self.xmitBuffer[0])\n\
      \            print(f\"input_items _len = {_len}\")\n            print(f\"input_items\
      \      = {len(self.xmitBuffer[0])}\")\n            print(f\"output_items   \
      \           = {len(output_items)}\")\n            print(f\"output_items[0] buflenlen\
      \ = {buflen}\")\n            print(f\"output_items[0]           = {len(output_items[0])}\"\
      )\n            \"\"\"self.add_item_tag(0, # Write to output port 0\n       \
      \           self.nitems_written(0) + _len, # Index of the tag in absolute terms\n\
      \                  pmt.intern(\"tx_sob\"),\n                  pmt.PMT_T\n  \
      \          )\n            self.add_item_tag(0, # Write to output port 0\n  \
      \                self.nitems_written(0), # Index of the tag in absolute terms\n\
      \                  pmt.intern(\"tx_eob\"),\n                  pmt.PMT_T\n  \
      \          )\"\"\"\n            for i in range(min(buflen, _len)):\n       \
      \         output_items[0][i] = self.xmitBuffer[0].pop(0)\n            if buflen\
      \ >= _len:\n                self.waiting = 1\n                self.xmitBuffer.pop(0)\n\
      \            return _len\n        else:\n            timer = time() - self.timer\n\
      \            sendNumber = int(timer//(1/9600*8))\n            if sendNumber\
      \ > 0: self.timer = time()\n            self.add_item_tag(0,\n             \
      \             self.nitems_written(0),\n                          pmt.intern(\"\
      tx_pkt_len\"),\n                          pmt.to_pmt(8*60*sendNumber)\n    \
      \            )\n            output_items[0][:len(self.flag) * sendNumber] =\
      \ self.flag * sendNumber\n            return len(self.flag) * sendNumber\n \
      \       \nif __name__ == \"__main__\":\n    \n\n    data = bytes((0x52, 0x82,\
      \ 0x88, 0xA6, 0x82, 0xA8, 0xF4, 0xA4, 0x82, 0x88, 0xA6, 0x82, 0xA8, 0x63, 0x03,\
      \ 0xF0, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2D, 0x53, 0x4B, 0x20, 0x52, 0x41,\
      \ 0x44, 0x53, 0x41, 0x54, 0x2D, 0x53, 0x4B, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41,\
      \ 0x54, 0x2D, 0x53, 0x4B, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2D, 0x53,\
      \ 0x4B, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2D, 0x53, 0x4B, 0x20, 0x52,\
      \ 0x41, 0x44, 0x53, 0x41, 0x54, 0x2D, 0x53, 0x4B, 0x20, 0x52, 0x41, 0x44, 0x53,\
      \ 0x41, 0x54, 0x2D, 0x53, 0x4B, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2D,\
      \ 0x53, 0x4B, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2D, 0x53, 0x4B, 0x20,\
      \ 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2D, 0x53, 0x4B, 0x20, 0x52, 0x41, 0x44,\
      \ 0x53, 0x41, 0x54, 0x2D, 0x53, 0x4B, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54,\
      \ 0x2D, 0x53, 0x4B, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2D, 0x53, 0x4B,\
      \ 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2D, 0x53, 0x4B, 0x20, 0x52, 0x41,\
      \ 0x44, 0x53, 0x41, 0x54, 0x2D, 0x53, 0x4B, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41,\
      \ 0x54, 0x2D, 0x53, 0x4B, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2D, 0x53,\
      \ 0x4B, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2D, 0x53, 0x4B, 0x20, 0x52,\
      \ 0x41, 0x44, 0x53, 0x41, 0x54, 0x2D, 0x53, 0x4B, 0x20, 0x52, 0x41, 0x44, 0x53,\
      \ 0x41, 0x54, 0x2D, 0x53, 0x4B, 0x20))\n\t\n    data2 = bytes((0xA4, 0x82, 0x88,\
      \ 0xA6, 0x82, 0xA8, 0xF4, 0xA4, 0x82, 0x88, 0xA6, 0x82, 0xA8, 0x63, 0x03, 0xF0,\
      \ 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2D, 0x53, 0x4B, 0x20, 0x52, 0x41, 0x44,\
      \ 0x53, 0x41, 0x54, 0x2D, 0x53, 0x4B, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54,\
      \ 0x2D, 0x53, 0x4B, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2D, 0x53, 0x4B,\
      \ 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2D, 0x53, 0x4B, 0x20, 0x52, 0x41,\
      \ 0x44, 0x53, 0x41, 0x54, 0x2D, 0x53, 0x4B, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41,\
      \ 0x54, 0x2D, 0x53, 0x4B, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2D, 0x53,\
      \ 0x4B, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2D, 0x53, 0x4B, 0x20, 0x52,\
      \ 0x41, 0x44, 0x53, 0x41, 0x54, 0x2D, 0x53, 0x4B, 0x20, 0x52, 0x41, 0x44, 0x53,\
      \ 0x41, 0x54, 0x2D, 0x53, 0x4B, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2D,\
      \ 0x53, 0x4B, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2D, 0x53, 0x4B, 0x20,\
      \ 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2D, 0x53, 0x4B, 0x20, 0x52, 0x41, 0x44,\
      \ 0x53, 0x41, 0x54, 0x2D, 0x53, 0x4B, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54,\
      \ 0x2D, 0x53, 0x4B, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2D, 0x53, 0x4B,\
      \ 0x20, 0x52, 0x41, 0x44, 0x53, 0x41, 0x54, 0x2D, 0x53, 0x4B, 0x20, 0x52, 0x41,\
      \ 0x44, 0x53, 0x41, 0x54, 0x2D, 0x53, 0x4B, 0x20, 0x52, 0x41, 0x44, 0x53, 0x41,\
      \ 0x54, 0x2D, 0x53, 0x4B, 0x20))\n\t\n    crc_calculator = crcAugCcitt()\n \
      \   print(\"False\", hex(crc_calculator.calculate_checksum(data)))\n    print(\"\
      True \", hex(crc_calculator.calculate_checksum(data2)))\n\t\n\t\n\t\n\t\n\t\n\
      \t\n\t\n\t\n\t\n           \n"
    affinity: ''
    alias: ''
    comment: ''
    ctl: '0x03'
    destinationAddress: destinationCallsign
    destinationIndex: destinationSsid
    maxoutbuf: '0'
    minoutbuf: '0'
    pid: '0xf0'
    sourceAddress: sourceCallsign
    sourceIndex: sourceSsid
  states:
    _io_cache: ('Embedded Python Block', 'blk', [('destinationAddress', "'RADSAT'"),
      ('destinationIndex', '1'), ('sourceAddress', "'RADSAT'"), ('sourceIndex', '10'),
      ('ctl', '240'), ('pid', '3')], [('msg_in', 'message', 1)], [('0', 'byte', 1)],
      'Embedded Python Block example - a simple multiply const', [])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [368, 268.0]
    rotation: 0
    state: enabled
- name: destinationCallsign
  id: parameter
  parameters:
    alias: ''
    comment: ''
    hide: none
    label: Destination Callsign
    short_id: ''
    type: str
    value: NOCALL
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [232, 12.0]
    rotation: 0
    state: true
- name: destinationSsid
  id: parameter
  parameters:
    alias: ''
    comment: ''
    hide: none
    label: Destination SSID
    short_id: ''
    type: intx
    value: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [232, 108.0]
    rotation: 0
    state: true
- name: digital_diff_encoder_bb_0
  id: digital_diff_encoder_bb
  parameters:
    affinity: ''
    alias: ''
    coding: digital.DIFF_NRZI
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    modulus: '2'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [728, 308.0]
    rotation: 0
    state: true
- name: digital_scrambler_bb_0
  id: digital_scrambler_bb
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    len: '16'
    mask: '0x21'
    maxoutbuf: '0'
    minoutbuf: '0'
    seed: '0x00'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [600, 292.0]
    rotation: 0
    state: enabled
- name: pad_sink_0
  id: pad_sink
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    label: out
    num_streams: '1'
    optional: 'False'
    type: byte
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [920, 308.0]
    rotation: 0
    state: true
- name: pad_source_0
  id: pad_source
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    label: Info in
    maxoutbuf: '0'
    minoutbuf: '0'
    num_streams: '1'
    optional: 'True'
    type: message
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [160, 308.0]
    rotation: 0
    state: true
- name: pad_source_0_0
  id: pad_source
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    label: Ctrl in
    maxoutbuf: '0'
    minoutbuf: '0'
    num_streams: '1'
    optional: 'True'
    type: message
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [160, 356.0]
    rotation: 0
    state: disabled
- name: sourceCallsign
  id: parameter
  parameters:
    alias: ''
    comment: ''
    hide: none
    label: Source Callsign
    short_id: ''
    type: str
    value: NOCALL
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [392, 12.0]
    rotation: 0
    state: true
- name: sourceSsid
  id: parameter
  parameters:
    alias: ''
    comment: ''
    hide: none
    label: Source SSID
    short_id: ''
    type: intx
    value: '2'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [392, 108.0]
    rotation: 0
    state: true

connections:
- [ax25_framer, '0', digital_scrambler_bb_0, '0']
- [digital_diff_encoder_bb_0, '0', pad_sink_0, '0']
- [digital_scrambler_bb_0, '0', digital_diff_encoder_bb_0, '0']
- [pad_source_0, out, ax25_framer, msg_in]
- [pad_source_0_0, out, ax25_framer, msg_in]

metadata:
  file_format: 1
